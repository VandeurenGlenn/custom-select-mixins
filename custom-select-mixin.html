<script>
  class CustomSelectMixin extends HTMLElement {
    static get observedAttributes() {
      return ['selected'];
    }

    static get properties() {
      return {
        selected: {
          value: 0,
          observer: '__selectedObserver__'
        }
      }
    }

    get slotted() {
      return this.shadowRoot.querySelector('slot');
    }

    get children() {
      return this.slotted.assignedNodes();
    }

    /**
    * @return {String}
    */
    get attrForSelected() {
     return this.getAttribute('attr-for-selected') || 'name';
    }

    set attrForSelected(value) {
     this.setAttribute('attr-for-selected', value);
    }

    created() {
      this.slotchange = this.slotchange.bind(this);
      this.slotted.addEventListener('slotchange', this.slotchange);
    }

    slotchange() {
      if (this.selected) {
        this.__selectedObserver__({value: this.selected})
      }
    }

    attributeChangedCallback(name, oldValue, newValue) {
      if (oldValue !== newValue) {
        // check if value is number
        if (!isNaN(newValue)) {
          newValue = Number(newValue);
        }
        this[name] = newValue;
      }
    }

    /**
     * @param {string|number|HTMLElement} selected
     */
    select(selected) {
      this.selected = selected;
    }

    next(string) {
      const index = this.children.indexOf(this.currentSelected);
      if (index !== -1 && index >= 0 && this.children.length > index &&
          (index + 1) <= this.children.length - 1) {
        this.selected = this.children[index + 1]
      }
    }

    previous() {
      const index = this.children.indexOf(this.currentSelected);
      if (index !== -1 && index >= 0 && this.children.length > index &&
          (index - 1) >= 0) {
        this.selected = this.children[index - 1]
      }
    }

    _updateSelected(selected) {
      selected.classList.add('custom-selected');
      if (this.currentSelected && this.currentSelected !== selected) {
        this.currentSelected.classList.remove('custom-selected');
      }
      this.currentSelected = selected;
    }

    /**
     * @param {string|number|HTMLElement} change.value
     */
    __selectedObserver__({value}) {
      switch (typeof value) {
        case 'object':
          this._updateSelected(value)
          break;
        case 'string':
          for (const child of this.children) {
            if (child.nodeType === 1) {
              if (child.getAttribute(this.attrForSelected) === value) {
                return this._updateSelected(child);
              }
            }
          }
          if (this.currentSelected) {
            this.currentSelected.classList.remove('custom-selected');
          }
          break;
        default:
          // set selected by index
          const child = this.children[value];
          if (child && child.nodeType === 1) {
            this._updateSelected(child);
          // remove selected even when nothing found, better to return nothing
          } else if (this.currentSelected) {
            this.currentSelected.classList.remove('custom-selected');
          }
      }
    }
  }
</script>
